using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Bricklayer.Core.Common.World
{
    /// <summary>
    /// A tile's block type (Ex: Dirt, Stone, etc)
    /// </summary>
    public class BlockType
    {
        private Image image;

        /// <summary>
        /// List of all block types. Blocks must be added as soon as plugins are loaded.
        /// </summary>
        public static List<BlockType> Blocks { get; }

        /// <summary>
        /// How players should collide with this tile. (Only used for foregrounds).
        /// </summary>
        public BlockCollision Collision { get; set; }

        /// <summary>
        /// The average color of the tile to appear on the minimap.
        /// </summary>
        public Color Color { get; set; }

        /// <summary>
        /// ID of this block used for loading and saving blocks.
        /// A list of IDs is generated by the server at startup, depending on what plugins are loaded and how many blocks they
        /// contain.
        /// </summary>
        public ushort ID { get; }

        /// <summary>
        /// Defines if this block is a background or foreground.
        /// </summary>
        public Layer Layer { get; set; }

        /// <summary>
        /// Name of the block.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The texture of this block. (Null on serverside)
        /// </summary>
        public Image Image
        {
            get { return image; }
            set
            {
                image = value;
                SourceRect = new Rectangle(image.SourceRect.X, image.SourceRect.Y + (Tile.FullWidth - Tile.Width), Tile.Width, Tile.Height);
                FullSourceRect = new Rectangle(image.SourceRect.X, image.SourceRect.Y, Tile.FullWidth, Tile.FullHeight);
            }
        }

        /// <summary>
        /// The function to draw this block.
        /// </summary>
        /// <remarks>
        /// Note: Using an Action instead of a method call or inlined code has no effect on performance :)
        /// </remarks>
        public Action<SpriteBatch, Tile, int, int, Layer> Draw { get; set; }

        /// <summary>
        /// Indicates whether or not this block has a texture and should be rendered.
        /// </summary>
        public bool IsRenderable { get; set; }

        /// <summary>
        /// The pack/category of this block.
        /// </summary>
        /// <remarks>
        /// Used for grouping in the inventory.
        /// Blocks in a pack must be placed in a subfolder in the Textures/blocks/ folder that corresponds with the name.
        /// </remarks>
        public BlockPack Pack { get; set; }

        /// <summary>
        /// Source rectangle for the face of a tile. (Not the 2.5d part)
        /// </summary>
        public Rectangle SourceRect { get; private set; }

        /// <summary>
        /// Source rectangle for the tile, including all faces. (2.5d)
        /// </summary>
        public Rectangle FullSourceRect { get; private set; }

        static BlockType()
        {
            // ReSharper disable once UseObjectOrCollectionInitializer
            Blocks = new List<BlockType>();

            // Add hardcoded blocks:
            // ReSharper disable once ObjectCreationAsStatement
            new BlockType("Empty", Layer.All) {IsRenderable = false};
        }

        /// <summary>
        /// Creates a new instance a block type and adds it to the block list.
        /// </summary>
        /// <param name="name">Name of the block</param>
        /// <param name="layer">The layer(s) the tile can be placed on.</param>
        /// <param name="collision">The physics that the tile will interact with entities with.</param>
        /// <param name="pack">Block category used for sorting in the inventory.</param>
        public BlockType(string name, Layer layer, BlockCollision collision = BlockCollision.Passable,
            BlockPack pack = null)
        {
            // TODO: ID will be calulcated by server, and the list will be rearranged after plugins are loaded
            // This way we can use an array or list instead of LINQ/for loop to find an id in `FromID`
            Name = name;
            Layer = layer;
            Collision = collision;
            Pack = pack;
            ID = (ushort) Blocks.Count();
            IsRenderable = true;

            Draw = (batch, tile, x, y, z) =>
            {
                if (z == Layer.Background)
                {
                    // If a foreground block is being drawn on the backgrount, make it darker automatically.
                    if (tile.Type.Layer.HasFlag(Layer.Foreground))
                        batch.Draw(Image, new Vector2((x*Tile.Width) + (Tile.FullWidth - Tile.Width), y*Tile.Height), SourceRect, Color.Gray);
                    else
                        batch.Draw(Image, new Vector2((x*Tile.Width) + (Tile.FullHeight - Tile.Height), y*Tile.Height), sourceRectangle: SourceRect);
                }
                else
                    batch.Draw(Image, new Vector2(x*Tile.Width, y*Tile.Height), sourceRectangle: FullSourceRect);
            };
            Blocks.Add(this);
        }

        /// <summary>
        /// Finds a <c>BlockType</c> from it's ID
        /// </summary>
        public static BlockType FromID(ushort ID)
        {
            // ReSharper disable once ForCanBeConvertedToForeach
            // ReSharper disable once LoopCanBeConvertedToQuery
            // For loop for optimization as this is called for every tile access
            for (var i = 0; i < Blocks.Count; i++)
            {
                var x = Blocks[i];
                if (x.ID == ID) return x;
            }
            return Blocks[0]; // Return empty block if block not found (Blocks not loaded by plugin?)
        }

        public override string ToString()
        {
            return Name;
        }

        /// <summary>
        /// Implicitly convert BlockType to Tile for convenience, as setting a tile requires: Tiles[x, y] = new Tile(type) without
        /// this.
        /// </summary>
        public static implicit operator Tile(BlockType type) => new Tile(type);

        /// <summary>
        /// Implicity convert Tile to BlockType for convenience, meaning Tile.Type is not neccessary.
        /// </summary>
        public static implicit operator BlockType(Tile tile) => tile.Type;

        public static bool operator ==(BlockType type, Tile tile) => type != null && tile.Type.ID == type.ID;

        public static bool operator !=(BlockType type, Tile tile) => !(type == tile);
    }
}